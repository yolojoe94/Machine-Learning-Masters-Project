# -*- coding: utf-8 -*-
"""
Created on Mon Jan  8 16:04:30 2024

@author: thejo
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

from tensorflow import keras
from scipy import ndimage
import os
os.environ["KMP_DUPLICATE_LIB_OK"]="TRUE"

'''plan:
    make 2d space array
    define squares
    construct large array of pairs of squares at 10 deg separation
    train CNN to identify sin and cos of orientation angle
    train NN to find separation angle/stereo angle
    works with cos(4x) in 0-360 range
    
    '''

gamma_glob = None

opt = keras.optimizers.Adam(learning_rate=0.01)


def grid2d(size):
    '''creates values of coords up to image size, then makes grid of coords.
    does this _number_ of times to make 3d grid of unrelated slices'''
    xx, yy = np.meshgrid(np.linspace(0,size-1,size),
                            np.linspace(0,size-1,size), sparse=True)
    return xx, yy


def preprocess(x, y, grid, dim):
    '''recenters image using average mass position
    doesnt work on y height ??'''
    proc = np.where(grid>0.3, 1, 0)
    dx = np.sum(x*proc)/np.sum(proc)-dim/2
    dy = np.sum(y*proc)/np.sum(proc)-dim/2
    im = np.roll(proc, -int(np.round(dy)), axis=0)
    im = np.roll(im, -int(np.round(dx)), axis=1)
    #this is just not moving the y coord for some reason
    return im

def inside_L(space, center, size, angle, dim):
    '''takes consts and defines region where inside square, sets the grid values to 1, else 0'''
    #l is the max square radius
    nx = np.sin(angle)
    ny = np.cos(angle) #normal vectors to edge, to determine if coord is inside or outside edge
    im_l = np.where((np.absolute((space[0]-center[0])*nx+(space[1]-center[1])*ny) < size/2)
                     & (np.absolute((space[0]-center[0])*ny-(space[1]-center[1])*nx) < size/2),
                     1, 0)
    im_l2 = im_l
    im_l2 = np.nonzero((np.absolute((space[0]-center[0])*nx+(space[1]-center[1])*ny) < size/2)
                       & (np.absolute((space[0]-center[0])*ny-(space[1]-center[1])*nx) < size/2))
    #second condition uses tangent vectors to edge to find other two edges
    #absolute allows both edges to be considered at once
    #size/2 is the half side length
    im_l = np.add(im_l, np.random.random([dim,dim])/5) #unprocessed image
    im_l = gaussian_filter(im_l, sigma=0.1)
    return preprocess(grid2d(dim)[0], grid2d(dim)[1], im_l, dim)

def data(dim, num, max_angle):
    '''creates dataset of num dim*(2*dim) images
    res determines number of intervals between 0 and 90 degrees
    returns arrays of shapes, the stereoimages for each shape and the angle between them'''
    a_s = np.zeros((num,3))
    c_s = np.zeros((num,2))
                      
    '''these are randomised start values for the shapes'''
    xcs = ((np.random.rand(num)-0.5)*2*dim/4 + dim/2).round(1)*0+dim/2
    ycs = ((np.random.rand(num)-0.5)*2*dim/4 + dim/2).round(1)*0+dim/2
    length = ((np.random.rand(num)+1)*dim/4).round(1)
    length[:] = dim/2
    #this 0, 90 defines the angular range of results
    a1 = (np.random.uniform(0, max_angle, num))#in degrees
    a2 = a1+10
    c_s[np.arange(num), np.zeros(num,int)] = xcs
    c_s[np.arange(num), np.zeros(num,int)+1] = ycs #centers
    
    a_s[np.arange(num), np.zeros(num,int)] = (a1/180*np.pi)#in radians
    a_s[np.arange(num), np.zeros(num,int)+1] = (a2/180*np.pi)#in radians
    # a_s[np.arange(num), np.zeros(num,int)+2] = np.absolute((a2*10-a1*10))#in degrees
    a_s[np.arange(num), np.zeros(num,int)+2] = a1#in degrees
    '''this is important, the validation for the training is the first angle.
    that means we will be asking for only one angle as our final output'''
    a = grid2d(dim)#grid for making pixels on
    
    grid1=[] #this is the list containing all image 1s of 2s
    grid2=[] #stereopair images
    proj1=[]
    proj2=[]
    for i in np.arange(num):
        c1 = inside_L(a, c_s[i], length[i], a_s[i][0], dim)
        c2 = inside_L(a, c_s[i], length[i], a_s[i][1], dim)
        grid1.append(c1)
        proj1.append(np.sum(c1, 1))
        proj2.append(np.sum(c2, 1))
        grid2.append(c2)
    print('proj1.shape = ', np.array(proj1).shape)
    grids = np.hstack([np.array([grid1]).reshape(-1, dim, dim, 1)*1.0,
               np.array([grid2]).reshape(-1, dim, dim, 1)*1.0])
    projections = np.hstack([np.array([proj1]).reshape(-1, dim, 1)*1.0,
               np.array([proj2]).reshape(-1, dim, 1)*1.0])
    print('projections.shape = ', projections.shape)
    return grids, projections, a_s



dim, num, max_angle, batch_size, epochs = 64, 2048, 60, 64, 25
opt = keras.optimizers.Adam(learning_rate=0.01)
train = data(dim, num, max_angle)

#data
X_1 = train[0][:, :dim, :, :]  # img1
Y_1 = train[0][:, dim:, :, :]  # img2
# X_2 = train[1][:, 1] - train[1][:, 0]  # stereoangles
# real_angles = train[1][:, 0]  # correct angle of first shape

print('train[1].shape = ', train[1].shape)
a = train[1][:, :dim, :]
print('a.shape = ', a.shape)
b = train[1][:, dim:, :]
print('a.shape, b.shape = ', a.shape, b.shape)
fig, axs = plt.subplots(2, 4)
fig.suptitle(f'IMG_model, max_angle={max_angle}')
axs[0,0].plot(np.arange(64), a[0])
# axs[0,0].set_title(f'{round(train[1][:,1][0]/np.pi*180,2)}$\degree$')
axs[0,1].plot(np.arange(64), b[0])
# axs[0,1].set_title(f'{round(train[1][:,1][1]/np.pi*180,2)}$\degree$')
axs[0,2].plot(np.arange(64), a[2])
# axs[0,2].set_title(f'{round(train[1][:,1][1]/np.pi*180,2)}$\degree$')
axs[0,3].plot(np.arange(64), b[2])
# axs[0,3].set_title(f'{round(train[1][:,1][1]/np.pi*180,2)}$\degree$')
axs[1,0].imshow(X_1[0], cmap='gray')
# axs[1,0].set_title(f'{round(train[1][:,1][0]/np.pi*180,2)}$\degree$')
axs[1,1].imshow(Y_1[0], cmap='gray')
# axs[1,1].set_title(f'{round(train[1][:,1][1]/np.pi*180,2)}$\degree$')
axs[1,2].imshow(X_1[2], cmap='gray')
# axs[1,2].set_title(f'{round(train[1][:,1][1]/np.pi*180,2)}$\degree$')
axs[1,3].imshow(Y_1[2], cmap='gray')
# axs[1,3].set_title(f'{round(train[1][:,1][1]/np.pi*180,2)}$\degree$')

# -*- coding: utf-8 -*-
"""
Created on Mon Jan  8 16:04:30 2024

@author: thejo
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter
from scipy.stats import moment, skew, describe

from tensorflow import keras
import tensorflow as tf
import tensorflow.math as tfm
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv1D, MaxPooling1D, Dropout
from tensorflow.keras.layers import Flatten, Dense
import os
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"

'''plan:
    make 2d space array
    define squares
    construct large array of pairs of squares at 10 deg separation
    train CNN to identify sin and cos of orientation angle
    train NN to find separation angle/stereo angle
    works with cos(4x) in 0-360 range
    
    '''


def grid2d(size):
    '''creates values of coords up to image size, then makes grid of coords.
    does this _number_ of times to make 3d grid of unrelated slices'''
    xx, yy = np.meshgrid(np.linspace(0, size-1, size),
                         np.linspace(0, size-1, size), sparse=True)
    return xx, yy


def preprocess(x, y, grid, dim):
    '''recenters image using average mass position
    doesnt work on y height ??'''

    dx = np.sum(x*grid)/np.sum(grid)-dim/2
    dy = np.sum(y*grid)/np.sum(grid)-dim/2
    im = np.roll(grid, -int(np.round(dy)), axis=0)
    im = np.roll(im, -int(np.round(dx)), axis=1)
    # this is just not moving the y coord for some reason
    return im


def inside_L(space, center1, size, angle, dim):
    '''takes consts and defines region where inside square, sets the grid values to 1, else 0'''
    # l is the max square radius
    # angle=0
    nx = np.sin(angle)
    # normal vectors to edge, to determine if coord is inside or outside edge
    ny = np.cos(angle)
    center = center1.copy()
    center_a = [size*(22/64), -size*(6/64)]#y,x right
    center_b = [size*(26/64), -size*(18/64)]#y,x left
    center2  = center + [center_b[0]*nx + center_b[1]
               * ny, center_b[0]*ny - center_b[1]*nx]
    center3  = center - [center_a[0]*nx + center_a[1]
               * ny, center_a[0]*ny - center_a[1]*nx]
    shift = (center + center2)/2 - dim/2
    center -= shift
    center2 -= shift
    center3 -= shift
    im_1 = np.where((np.absolute((space[0]-center[0])*nx+(space[1]-center[1])*ny) <= size*(18/64))
                    & (np.absolute((space[0]-center[0])*ny-(space[1]-center[1])*nx) <= size*(6/64)),#middle
                    1, 0)
    im_2 = np.where((np.absolute((space[0]-center2[0])*nx+(space[1]-center2[1])*ny) <= size*(8/64))
                    & (np.absolute((space[0]-center2[0])*ny-(space[1]-center2[1])*nx) <= size*(24/64)),#left
                    1, 0)
    im_3 = np.where((np.absolute((space[0]-center3[0])*nx+(space[1]-center3[1])*ny) <= size*(4/64))
                    & (np.absolute((space[0]-center3[0])*ny-(space[1]-center3[1])*nx) <= size*(12/64)),#right
                    1, 0)
    # second condition uses tangent vectors to edge to find other two edges
    # absolute allows both edges to be considered at once
    im_l = np.add(im_1, im_2, np.random.random(
        [dim, dim])/5) + im_3  # unprocessed image
    im_l = gaussian_filter(im_l, sigma=0.1)
    return preprocess(grid2d(dim)[0], grid2d(dim)[1], im_l, dim)
    # return np.where(im_l>0.3, 1, 0)


def data_vars(dim, num, min_angle, max_angle):
    '''creates dataset of num dim*(2*dim) images
    res determines number of intervals between 0 and 90 degrees
    returns arrays of shapes, the stereoimages for each shape and the angle between them'''
    a_s = np.zeros((num, 3))
    c_s = np.zeros((num, 2))

    '''these are randomised start values for the shapes'''
    xcs = ((np.random.rand(num)-0.5)*2*dim/4 + dim/2)*0 + 3*dim/8
    ycs = ((np.random.rand(num)-0.5)*2*dim/4 + dim/2)*0 + dim/2
    length = ((np.random.rand(num)-0.5)*dim/4 + 5*dim/8)/1.2
    # length[:] = dim/2
    # this 0, 90 defines the angular range of results
    a1 = (np.random.uniform(min_angle, max_angle, num))  # in degrees
    a2 = a1+10
    c_s[np.arange(num), np.zeros(num, int)] = xcs
    c_s[np.arange(num), np.zeros(num, int)+1] = ycs  # centers

    a_s[np.arange(num), np.zeros(num, int)] = (a1/180*np.pi)  # in radians
    a_s[np.arange(num), np.zeros(num, int)+1] = (a2/180*np.pi)  # in radians
    a_s[np.arange(num), np.zeros(num, int)+2] = a1  # in degrees
    return c_s, length, a_s


def data(c_s, length, a_s, dim, num, min_angle, max_angle):
    # c_s, length, a_s = data_vars(dim, num, min_angle, max_angle)
    a = grid2d(dim)  # grid for making pixels on

    grid1 = []  # this is the list containing all image 1s of 2s
    grid2 = []  # stereopair images
    proj1 = []
    proj2 = []
    x = np.arange(0, 64)
    for i in np.arange(num):
        c1 = inside_L(a, c_s[i], length[i], a_s[i][0], dim)
        c2 = inside_L(a, c_s[i], length[i], a_s[i][1], dim)
        grid1.append(c1)
        dx = np.sum(x*np.sum(c1, 0))/np.sum(np.sum(c1, 0))-dim/2
        im = np.roll(np.sum(c1, 0), -int(np.round(dx)), axis=0)
        proj1.append(im)
        dx = np.sum(x*np.sum(c2, 0))/np.sum(np.sum(c2, 0))-dim/2
        im = np.roll(np.sum(c2, 0), -int(np.round(dx)), axis=0)
        proj2.append(im)
        grid2.append(c2)
    grids = np.hstack([np.array([grid1]).reshape(-1, dim, dim, 1)*1.0,
        np.array([grid2]).reshape(-1, dim, dim, 1)*1.0])
    projections = np.hstack([np.array([proj1]).reshape(-1, dim, 1)*1.0,
                             np.array([proj2]).reshape(-1, dim, 1)*1.0])
    return grids, projections, a_s
    # return [], projections, a_s


def CNN_1d_model(dim):
    '''takes a projection input
    outputs an angle for the image orientation'''
    inputs = Input(shape=(dim, 1))
    x = Conv1D(16, kernel_size=(3), activation='relu', padding='same')(inputs)
    x = MaxPooling1D(pool_size=(2))(x)
    x = Dropout(0.1)(x)
    x = Conv1D(32, kernel_size=(3), activation='relu', padding='same')(x)
    x = MaxPooling1D(pool_size=(2))(x)
    x = Dropout(0.1)(x)
    x = Conv1D(16, kernel_size=(3), activation='relu', padding='same')(x)
    x = MaxPooling1D(pool_size=(2))(x)
    x = Dropout(0.1)(x)
    x = Flatten()(x)
    x = Dense(16, activation='relu')(x)
    outputs = Dense(2, activation='linear')(x)
    # angle1 = tfm.atan2(x[:, 0], x[:, 1], name="angle1")
    # outputs = tf.reshape(angle1, [-1, 1])
    model = Model(inputs=inputs, outputs=outputs)
    model.summary()
    return model


def CNN_CHEAT(dim):
    '''takes a projection input
    outputs an angle for the image orientation
    USES GROUND TRUTH'''
    inputs = Input(shape=(dim, 1))
    x = Conv1D(16, kernel_size=(3), activation='relu', padding='same')(inputs)
    x = MaxPooling1D(pool_size=(2))(x)
    x = Dropout(0.1)(x)
    x = Conv1D(32, kernel_size=(3), activation='relu', padding='same')(x)
    x = MaxPooling1D(pool_size=(2))(x)
    x = Dropout(0.1)(x)
    x = Conv1D(16, kernel_size=(3), activation='relu', padding='same')(x)
    x = MaxPooling1D(pool_size=(2))(x)
    x = Dropout(0.1)(x)
    x = Flatten()(x)
    x = Dense(16, activation='relu')(x)
    outputs = Dense(2, activation='linear')(x)
    # angle1 = tfm.atan2(x[:, 0], x[:, 1], name="angle1")
    # outputs = tf.reshape(angle1, [-1, 1])
    model = Model(inputs=inputs, outputs=outputs)
    model.summary()
    return model


def STEREO_1d_model(dim, num):
    '''takes a double width dual projection, splits and determines the angle of each
    then outputs a single angle
    in theory: it takes correct angles from both shapes and only returns shape two,
    this means you can give it a 0&unknown angle pair to get the unknowns,
    it is accurate on both as the same CNN is trained on each of images 1&2'''
    cnn_1d_model = CNN_1d_model(dim)
    inputs_st1 = Input(shape=(dim, 1))
    inputs_st2 = Input(shape=(dim, 1))
    # calculate angles of shape 1&2
    a1 = cnn_1d_model(inputs_st1)
    a2 = cnn_1d_model(inputs_st2)
    angle1 = tfm.atan2(a1[:, 0], a1[:, 1], name="angle1")
    c1 = tf.reshape(angle1, [-1, 1])
    angle2 = tfm.atan2(a2[:, 0], a2[:, 1], name="angle1")
    c2 = tf.reshape(angle2, [-1, 1])
    # difference in angle
    sub = tfm.subtract(a2, a1)
    # find index of lowest angle
    cs = tf.concat([c1, c2], 1)
    '''should this be argmin or argmax???'''
    x = tfm.argmin(cs, output_type=tf.dtypes.int32, axis=1)
    x = tf.reshape(x, [-1, 1])
    # multiply 2pi by index: = {0; if 1 is smaller, 1; if 2 is larger}
    y = tfm.multiply(tf.constant(3.14159265*2),
                     tf.cast(x, dtype=tf.dtypes.float32))
    y = tf.reshape(y, [-1, 1])
    # add 2pi if sub was negative
    add = tfm.add(sub, y)
    # make it a layer so it can be called later
    add = Dense(1, activation=None, use_bias=False, trainable=False,
                kernel_initializer=keras.initializers.Constant(value=1.0), name="stereo_out")(add)

    stereo_model = Model(inputs=[inputs_st1, inputs_st2], outputs=add)
    stereo_model.summary()

    return stereo_model, cnn_1d_model


def STEREO_CHEAT(model, dim, num):
    '''takes TWO IMAGES
    CHEATS TO GET THIER ANGLES
    SUBTRACTS THEM TO FIND STEREO ANGLE'''
    # cnn_CHEAT = CNN_CHEAT(dim)
    inputs_st1 = Input(shape=(dim, 1))
    inputs_st2 = Input(shape=(dim, 1))
    # calculate angles of shape 1&2
    a1 = cnn_CHEAT(inputs_st1)
    a2 = cnn_CHEAT(inputs_st2)
    angle1 = tfm.atan2(a1[:, 0], a1[:, 1], name="angle1")
    c1 = tf.reshape(angle1, [-1, 1])
    angle2 = tfm.atan2(a2[:, 0], a2[:, 1], name="angle1")
    c2 = tf.reshape(angle1, [-1, 1])
    # difference in angle
    sub = tfm.subtract(a2, a1)
    # find index of lowest angle
    cs = tf.concat([c1, c2], 1)
    '''should this be argmin or argmax???'''
    x = tfm.argmin(cs, output_type=tf.dtypes.int32, axis=1)
    x = tf.reshape(x, [-1, 1])
    # multiply 2pi by index: = {0; if 1 is smaller, 1; if 2 is larger}
    y = tfm.multiply(tf.constant(3.14159265*2),
                     tf.cast(x, dtype=tf.dtypes.float32))
    y = tf.reshape(y, [-1, 1])
    # add 2pi if sub was negative
    add = tfm.add(sub, y)
    # make it a layer so it can be called later
    add = Dense(1, activation=None, use_bias=False, trainable=False,
                kernel_initializer=keras.initializers.Constant(value=1.0), name="stereo_out")(add)

    stereo_CHEAT = Model(inputs=[inputs_st1, inputs_st2], outputs=add)
    stereo_CHEAT.summary()
    return stereo_CHEAT, cnn_CHEAT

def create_data(dim, num, min_angle, max_angle):
    if os.path.exists('temp.npy'):
        d = np.load('temp.npy')
        dim1, num1, min_angle1, max_angle1, start_data = d
        if (dim1, num1, min_angle1, max_angle1) == (dim, num, min_angle, max_angle):
            return start_data
    c_s, length, a_s = data_vars(dim, num, min_angle, max_angle)
    start_data = data(c_s, length, a_s, dim, num, min_angle, max_angle)
    np.save('temp.npy', (dim, num, min_angle, max_angle, start_data))
    return start_data

def MASK(dim, dataset):
    '''make a mask for a given dataset'''
    # dataset=start_data
    u = np.arange(-32, 32)
    v = dataset[1][:, :dim, 0]  # proj1
    # correct angle of first shape in radians
    real_angles_start_data = dataset[2][:, 0]
    # m = np.mean(u[None, :]*v, axis=1)/np.mean(v, axis=1)
    w = np.mean(u[None, :]**2*v, axis=1)/np.mean(v, axis=1)**2
    s = np.mean(u[None, :]**3*v, axis=1)/np.mean(v, axis=1)**3
    # plt.plot(real_angles_start_data, m, '.')
    # plt.plot(real_angles_start_data, w, '.')
    # plt.plot(real_angles_start_data, s, '.')
    # plt.show()
    mask = (w > 11)*(s > 7)
    # print(np.where(mask == True)[0].shape)
    # print(np.min(real_angles_start_data[mask]), '\n', np.max(real_angles_start_data[mask]))
    # make larger dataset, select only a few hundred through mask
    # train on mask to establish gradient
    # expand training back to 2048 to extend gradient for angular range
    # plt.plot(real_angles_start_data[mask], '.')
    # plt.show()
    return np.where(mask == True)[0], np.min(real_angles_start_data[mask]), np.max(real_angles_start_data[mask])


# mask, mask_min, mask_max = MASK(dim, start_data)
# mn = np.rad2deg(mask_min)
# mx = np.rad2deg(mask_max)

# v1 = start_data[1][mask, :dim, :]  # proj1
# v2 = start_data[1][mask, dim:, :]  # proj2
# w1 = start_data[2][mask, 0]  # real angles shape 1
# ster = start_data[2][mask, 1] - start_data[2][mask, 0]  # stereoangles


# stereo1d_model, cnn1d_model = STEREO_1d_model(dim, num)
# stereo1d_model.compile(optimizer=opt, loss="mse")
# history1 = stereo1d_model.fit(x=[v1, v2], y=ster, epochs=epochs, batch_size=batch_size)


def CNN_check(model1, dim, num, min_angle, max_angle):
    '''take range of inputs and produce graph of them vs predicitons from a model
    x-axis: values of shape 1's angle
    y-axis: predicted angule'''
    # generate test data
    c_s, length, a_s = data_vars(dim, num, -180, 180)
    test = data(c_s, length, a_s, dim, num, -180, 180)
    X_1 = test[1][:, :dim, :]
    real_angles_deg = np.rad2deg(test[2][:, 0])
    p = model1.predict(X_1)
    p = np.arctan2(p[:, 0], p[:, 1])
    print(p.shape)
    print(real_angles_deg.shape)
    plt.vlines(min_angle, np.min(np.rad2deg(p)), np.max(np.rad2deg(p)), 'b', label='min')
    plt.vlines(max_angle, np.min(np.rad2deg(p)), np.max(np.rad2deg(p)), 'b', label='max')
    plt.plot([min_angle, max_angle], [min_angle, max_angle], 'r-', label='line of hope')
    # p = np.rad2deg(np.arctan2(p[:,0], p[:,1]))
    # scatter the results
    plt.scatter(real_angles_deg, np.rad2deg(p))
    plt.grid()
    plt.xlabel('Actual Values of shape 1')
    plt.ylabel('Shape 1 Angle Prediction')
    plt.title(f'shape 1 angle predictions\nmin_angle={min_angle}\nmax_angle={max_angle}')
    plt.show()


def STEREO_check(model1, dim, num, min_angle, max_angle):
    '''take range of inputs and produce graph of them vs predicitons from a model
    x-axis: values of shape 1's angle
    y-axis: predicted stereo angle'''
    # generate test data
    c_s, length, a_s = data_vars(dim, num, -180, 180)
    test = data(c_s, length, a_s, dim, num, -180, 180)
    X_1 = test[1][:, :dim, :]
    Y_1 = test[1][:, dim:, :]
    real_angles_deg = np.rad2deg(test[2][:, 1])
    p = model1.predict([X_1, Y_1]).T
    # scatter the results
    plt.scatter(real_angles_deg, np.rad2deg(p), s=5)
    plt.vlines(min_angle, 0, 20, 'b')
    plt.vlines(max_angle, 0, 20, 'b')
    plt.hlines(10, -180, 180, 'g')
    plt.grid()
    plt.xlabel('Actual Values of shape 1')
    plt.ylabel('Stereo Angle Prediction')
    plt.title(f'stereo angle prediction\nmin_angle={min_angle}\nmax_angle={max_angle}')
    plt.show()


# CNN_check(cnn1d_model, dim, 2048, mn, mx)
# STEREO_check(stereo1d_model, dim, 2048, mn, mx)
# plt.plot(history1.history['loss'][int(round(0.1*len(history1.history['loss']), 0)):])
# plt.show()
# plt.plot(history1.history['loss'][:-int(round(0.1*len(history1.history['loss']), 0))])
# plt.show()
# assert False  # this is here to stop me accidentally writing over a saved file
# stereo1d_model.save('mask_trained4.keras')


def show_shapes(dim, dataset, num, max_angle, inds=None):
    Z_1 = dataset[0][:, :dim, :, :]  # img1
    a = dataset[1][:, :dim, :]
    b = dataset[2][:, 2]
    if inds is None:
        inds = np.random.randint(0, num, (3))
    fig, axs = plt.subplots(2, len(inds))
    fig.suptitle(f'IMG_model, max_angle={max_angle}')
    for k, i in enumerate(inds):
        axs[0, k].plot(np.arange(64), a[i])
        axs[0, k].title.set_text(f'{round(b[i])}')
        axs[0, k].set_yticklabels([])
        axs[1, k].imshow(Z_1[i], cmap='gray')
        axs[1, k].set_yticklabels([])
    plt.yticks([])
    plt.show()

# show_shapes(dim, start_data, num)

def show_stereo_2d(dim, dataset, num, max_angle, inds=None):
    Z_1 = dataset[0][:, :dim, :, :]  # img1
    Z_2 = dataset[0][:, dim:, :, :]  # img2
    b = dataset[2][:, 2] #angles degrees
    if inds is None:
        inds = np.random.randint(0, num, (3))
    fig, axs = plt.subplots(2, len(inds))
    fig.suptitle(f'IMG_model, max_angle={max_angle}')
    for k, i in enumerate(inds):
        axs[0, k].imshow(Z_1[i], cmap='gray')
        axs[1, k].imshow(Z_2[i], cmap='gray')
    plt.yticks([])
    plt.show()

dim, num, amin, amax, batch_size, epochs = 64, 4*1024, -180, 180, 64, 5
opt = keras.optimizers.Adam(learning_rate=0.01)
c_s, length, a_s = data_vars(dim, num, amin, amax)
train_data = data(c_s, length, a_s, dim, num, amin, amax)
X_st1 = train_data[1][:, :dim, :]  # proj1
X_st2 = train_data[1][:, dim:, :]  # proj2
Y = train_data[2]
Y_train = train_data[2][:, 1] - train_data[2][:, 0]  # stereoangles

stereo1d_model, cnn1d_model = STEREO_1d_model(dim, num)
losses = {"stereo_out": "mse"}
lossWeights = {"stereo_out": 1.0}
stereo1d_model.compile(optimizer=opt, loss=losses, loss_weights=lossWeights)

# pick a random image
n = np.random.randint(0, num)
# define a metric for image similarity
diff = np.std(X_st1[:, :, 0] - X_st1[n, :, 0], axis=1)
plt.plot(Y[:,0], diff, '.')
plt.show()

h = []

for sim in [1.5, 2.5, 4, 6, 100]:
    history2 = stereo1d_model.fit(x=[X_st1[diff<sim, ...], X_st2[diff<sim, ...]],
                                y=Y_train[diff<sim, ...], epochs=epochs, batch_size=batch_size)
    h.append(history2.history)  
    CNN_check(cnn1d_model, dim, 1024, -180, 180)
    STEREO_check(stereo1d_model, dim, 1024, -180, 180)

    plt.plot(history2.history["loss"])
    plt.yscale("log")
    plt.title('STEREO')
    plt.show()

plt.plot(np.array([he['loss'] for he in h]).flatten())
plt.yscale("log")
plt.title('STEREO')
plt.show()

